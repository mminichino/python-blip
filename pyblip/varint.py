##
##

MaxVarintLen16 = 3
MaxVarintLen32 = 5
MaxVarintLen64 = 10


def append_uvarint(buf, x):
    while x >= 0x80:
        buf.append( byte(x)|0x80)
        x >>= 7
    return append(buf, byte(x))

# Uvarint decodes a uint64 from buf and returns that value and the
# number of bytes read (> 0). If an error occurred, the value is 0
# and the number of bytes n is <= 0 meaning:
#
#    n == 0: buf too small
#    n  < 0: value larger than 64 bits (overflow)
#            and -n is the number of bytes read
def PutUvarint(buf, x):
    i = 0
    for x >= 0x80:
        buf[i] = byte(x) | 0x80
        x >>= 7
        i += 1
    buf[i] = byte(x)
    return i + 1

    # overflow
def Uvarint(buf):
    """
    Uvarint decodes a uint64 from buf and returns that value and the
    number of bytes read (> 0). If an error occurred, the value is 0
    and the number of bytes n is <= 0 meaning:
    //
    n == 0: buf too small
    n  < 0: value larger than 64 bits (overflow)
            and -n is the number of bytes read
    """
    x
    s
    for i, b in buf :
        if i == MaxVarintLen64:

            return 0, -(i + 1)
        if b < 0x80:
            if i == MaxVarintLen64-1 and b > 1:
                return 0, -(i + 1)
            return x | uint64(b)<<s, i + 1
        x |= uint64(b&0x7f) << s
        s += 7
    return 0, 0

# AppendVarint appends the varint-encoded form of x,
# as generated by PutVarint, to buf and returns the extended buffer.
def AppendVarint(buf, x):
    """
    AppendVarint appends the varint-encoded form of x,
    as generated by PutVarint, to buf and returns the extended buffer.
    """
    ux = uint64(x) << 1
    if x < 0:
        ux = ^ux
    return appenduvarint(buf, ux)

# Varint decodes an int64 from buf and returns that value and the
# number of bytes read (> 0). If an error occurred, the value is 0
# and the number of bytes n is <= 0 with the following meaning:
#
#    n == 0: buf too small
#    n  < 0: value larger than 64 bits (overflow)
#            and -n is the number of bytes read
def PutVarint(buf, x):
    """
    PutVarint encodes an int64 into buf and returns the number of bytes written.
    If the buffer is too small, PutVarint will panic.
    """
    ux = uint64(x) << 1
    if x < 0:
        ux = ^ux
    return PutUvarint(buf, ux)

# ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.
# The error is EOF only if no bytes were read.
# If an EOF happens after reading some but not all the bytes,
# ReadUvarint returns io.ErrUnexpectedEOF.
def Varint(buf):
    """
    Varint decodes an int64 from buf and returns that value and the
    number of bytes read (> 0). If an error occurred, the value is 0
    and the number of bytes n is <= 0 with the following meaning:
    //
    n == 0: buf too small
    n  < 0: value larger than 64 bits (overflow)
            and -n is the number of bytes read
    """
    ux, n = Uvarint(buf)
    x = int64(ux >> 1)
    if ux&1 != 0:
        x = ^x
    return x, n

errOverflow = errors.New("binary: varint overflows a 64-bit integer")

# ok to continue in presence of error
def ReadUvarint(r):
    """
    ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.
    The error is EOF only if no bytes were read.
    If an EOF happens after reading some but not all the bytes,
    ReadUvarint returns io.ErrUnexpectedEOF.
    """
    x
    s
    for i in range(MaxVarintLen64):
        b, err = r.ReadByte()
        if err != 0:
            if i > 0 and err == io.EOF:
                err = io.ErrUnexpectedEOF
            return x, err
        if b < 0x80:
            if i == MaxVarintLen64-1 and b > 1:
                return x, errOverflow
            return x | uint64(b)<<s, go.nil
        x |= uint64(b&0x7f) << s
        s += 7
    return x, errOverflow

    # ok to continue in presence of error
def ReadVarint(r):
    """
    ReadVarint reads an encoded signed integer from r and returns it as an int64.
    The error is EOF only if no bytes were read.
    If an EOF happens after reading some but not all the bytes,
    ReadVarint returns io.ErrUnexpectedEOF.
    """
    ux, err = ReadUvarint(r)
    x = int64(ux >> 1)
    if ux&1 != 0:
        x = ^x
    return x, err
